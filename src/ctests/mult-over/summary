We've noticed some odd differences in PAPI between perfmon and perfctr
when using overflows based on multiple events.

(1) First, when constructing an event set for multiple events and
launching overflow on them, should the order of the PAPI calls go:

  (A) add event, add event, ..., overflow, overflow, ...
  (B) add event, overflow, add event, overflow, ...

With perfmon, the order doesn't seem to matter, both work.

With perfctr, order (A) works, but (B) fails.  With (B), it only gives
interrupts on the last event added.  Further, (B) fails silently, none
of the PAPI calls returns an error, you just don't get the interrupts
that you expect.

Is this expected?
Is one order correct and the other order wrong?

I couldn't find anything in the PAPI man pages that clearly stated if
one was right and one was wrong.

(2) Second, the encodings in the overflow vector are different between
perfmon and perfctr.  I wrote a test program that creates an event set
with three events, in this order:

PAPI_TOT_CYC
PAPI_FP_INS
PAPI_FAD_INS

With perfmon, bit #0 (int 1) is the first one, PAPI_TOT_CYC, and bit
#2 (int 4) is the last one, PAPI_FAD_INS.  It goes least significant
bit to most significant.

With perfctr, it's the reverse: the first event, PAPI_TOT_CYC, is the
high bit, #2 (int 4), and the last one is bit #0 (int 1).

I can verify that's the case from the sequence of interrupts.  The
sequence of events matches up, but their encodings do not.

As long as you always use PAPI_get_overflow_event_index() to decode
the bits, you get the right answer, but it seemed odd.

I was wondering if that was expected or intentional or cause for
concern.  Also, there's kinda the temptation to unpack the overflow
vector yourself, since it's just a simple bit vector.  But that method
would fail on one platform.



create table dept 
(
   deptname char(15) not null,
   deptfloor integer not null,
   deptphone char(9) not null,
   empno  integer not null,
   primary key (deptname)
);

create table emp
(
  empno integer not null,
  empfname char(20) not null,
  empsalary integer not null,
  deptname char(15) not null,
  bossno   integer,
  primary key (empno),
  foreign key (deptname) references dept
);


insert into dept values('Accounting', 4, '2003', 5);
insert into dept values('Management', 5, '2001', 1);
insert into dept values('Marketing', 1, '2002', 2);
insert into dept values('Personnel', 1, '2005', 9);
insert into dept values('Purchasing', 4, '2004', 7);


insert into emp values(1,'Alice',75000,'Management',0);
insert into emp values(2,'Ned',45000,'Marketing',1);
insert into emp values(3,'Andrew',25000,'Marketing',2);
insert into emp values(4,'Clare',22000,'Marketing',2);
insert into emp values(5,'Todd',38000,'Accounting',1);
insert into emp values(6,'Nancy',22000,'Accounting',5);
insert into emp values(7,'Brier',43000,'Purchasing',1);
insert into emp values(8,'Sarah',56000,'Purchasing',7);
insert into emp values(9,'Sophie',35000,'Personnel',1);


5.
select emp.deptname
from emp
group by deptname
having (avg(empsalary) >35000);

8.
 select emp.empfname
 from  emp
 where emp.empsalary > ( select max(empsalary)
                         from emp
                         group by emp.deptname
                         having emp.deptname='Marketing');

6.
 select distinct emp.deptname
 from emp
 group by emp.deptname, bossno
 having ( avg(emp.empsalary) > 25000 )
 order by emp.deptname;


Normalization:

  student(SID, name, address);
  course(cid, title, instructor, term, year);
  instructor(name, location);
  major(sid, departname);
  grades(sid,cid,term,year,grades);


14.1:
  such a feature would conflict with the objective of transaction atomicity.
If a transaction could commit some but not all of its updates, then the 
uncommitted ones might subsequently be rolled back, whereas the commited ones
of course could not be. Thus, the transaction would no longer be "all or 
nothing".


14.3:
  Write ahead log rule:  the log must be physically written before COMMIT
    processing can completed .  This can guarantee if a transaction 
  successfully commits, then the updates will be permanently installed in 
the database, even if the system crashes the very next moment. 
   It's quite possible that the system might crash after the COMMIT has been
honored but before the updates have been physically written to the database--
they might still be waiting in a main memory buffer and so be lost at the time
of the crash. Even if that happen, the system's restart procedure will still 
install those updates in the database by examining the log.

14.4:

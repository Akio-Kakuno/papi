
            ------------------------------------------------------
                                      pfmon-1.0
	                   A sample tool to access the IA-64 PMU 
			            on Linux/ia64
            ------------------------------------------------------
		   Copyright (c) 2001-2002 Hewlett-Packard Company
		                 Stephane Eranian <eranian@hpl.hp.com>
	

Pfmon is a performance monitoring tool uniquely designed for Linux/ia64.
It does not work with Linux/ia32. It is meant as a sample tool to demonstrate
how to use the perfmon subsystem provided by the Linux/ia64 as of version 2.4.0.
This tool uses the powerful IA-64 Performance Monitoring Unit (PMU) to 
do counting and sampling on unmodified binaries.


This document is an attempt at providing some documentation on how to use pfmon. 
The content covers pfmon-1.0 uniquely. 

                -----> YOU MUST at least HAVE kernel v2.4.18 <-----

1/ Introduction

   Pfmon can be used to monitor unmodified binaries in its per-process mode ans it can 
   also be used to run system wide monitoring sessions. Such sessions are active across 
   all processes executing on a given CPU. Pfmon can launch a system wide session 
   on a dedicated CPU or set of CPUs in parallel. 

   Pfmon can monitor activities happening at the user and/or kernel level for both
   type of sessions. 

   Pfmon can be used to collect basic event counts. It can also be used to sample 
   program or system execution.

   In per-process mode, pfmon can only monitor the first process (task). Subsequent processes or 
   threads created by that  initial process will not be monitored. 

   Pfmon can run on any IA-64 CPU model and provide the minimal feature mandated
   by the architecture but it also provides model specific extensions. For instance,
   on Itanium pfmon has support for the EAR and BTB features.

   Pfmon is based on a generic helper library called libpfm which is included in this package.
   The library is not specific to pfmon and can be used directly by other programs as is
   demonstrated in the set of examples also included in this package. Both the library and
   pfmon have a modular architecture which make it easier to support new CPU models as they
   become available.

   In the remainder of this document, we now describe the key options and features of pfmon
   as well as some of the advanced features supported on the Itanium processor.

2/ pfmon options

   The set of command line options provided by pfmon depends on the host CPU. It is possible
   to compile pfmon for more than one CPU model and then it will auto-detect the host CPU and
   provide the corresponding set of options.

   The options common to all CPU models are as follows:

   -h, --help                           display the list of supported options

   -V, --version                        display pfmon version information

   -l, --show-event-list                show list of supported events for the host CPU 

   -i <event>, --event-info=event       get information about a particular event.

   -u, --user-level                     monitor at the user level for all events

   -k, --kernel-level                   monitor at the kernel level for all events

   -e, --events=ev1,ev2,...             select events to monitor. There should be no space
					between the events.

					The number of events that you can specify is dependent
					on the underlying CPU model. Four events is typical.

   -L,--list-supported-cpus             list the compiled in CPU models supported by pfmon and
   					detected host CPU.

   --debug                              enable debug prints.

   --verbose                            print more information during execution.

   --outfile=filename                   print counts in a file

   --append                             when used with --outfile, will open the file in append mode.

   --overflow-block                     do not block the monitored program on overflow 
   					notifications.

   --system-wide                        create a system wide monitoring session

   --cpu-mask=0xn                       bitmask indicating on which CPU to start system wide 
   					monitoring. When this option is not specified, pfmon will
					monitor on all CPUs.

   -t secs, --session-timeout=secs      duration of the system wide session in seconds. If not 
   					specified will wait for user to press <Enter>.

   --smpl-outfile=filename              save sampling results in a file.

   --smpl-entries=val                   size of the sampling buffer in number of entries 
   					(default=2048).

   --long-smpl-periods=val1,val2,...    set sampling periods for each event after user level 
   					notification.

   --short-smpl-periods=val1,val2,...   set sampling period for each event.

   --compact-smpl-output                enable compact output for sampling results.

   --raw-trace-file                     enable raw output for sampling results.

   --with-header                        generate a machine description header for results.

   --smpl-no-entry-header               do not generate a cpu,pid,tstamp header in sampling entries.

   --aggregate-results                  aggregate counts and sampling buffer outputs when running
   					system wide monitoring on multiple CPUs.

   --start-address=addr			start monitoring only when execution reaches addr

3/ Getting event information with pfmon

   The list of events supported by pfmon depends on the host CPU. You can get the list
   of support events using the following pfmon option:

   % pfmon -l
   CPU_CYCLES
   IA64_INST_RETIRED
   IA64_TAGGED_INST_RETIRED_PMC8
   IA64_TAGGED_INST_RETIRED_PMC9
   INST_DISPERSED
   EXPL_STOPBITS
   ALL_STOPS_DISPERSED
   IA32_INST_RETIRED
   ISA_TRANSITIONS
   NOPS_RETIRED
   ....

   You can get more detailed information about each event using the following option:

   % pfmon -i nops_retired
   Name   : NOPS_RETIRED
   VCode  : 0x30
   Code   : 0x30
   PMD/PMC: [ 4 5 ]
   EAR    : No (N/A)
   Umask  : None
   BTB    : No
   Thres  : 6
   Qual   : [Instruction Address Range] [OpCode match]

   Pfmon is case insensitive for event names. Here you see some details about the event.
   The first 4 lines are generic and provided on all CPU models even though the codes may
   vary:
  	- Code is the event code used by the PMU. 

	- Vcode is a libpfm internal event code which encapsulates the event code and other
	  information describing the type of the event. For simple events, the two codes are
	  usually identical.

	- PMD/PMC: list the counting monitors on which this event can be programmed. Not 
		   all events can necessarily be programmed on all available counting 
		   monitors. This constraint is taken care of by the libpfm library.

   The remaining information is specific to the Itanium CPU.

   Events can be specified using their code or vcodes:
   % pfmon -i 0x45
     Name   : BUS_SNOOPS_HITM_ANY
     VCode  : 0x10045
     Code   : 0x45
     PMD/PMC: [ 4 5 6 7 ]
     EAR    : No (N/A)
     Umask  : 0001
     BTB    : No
     Thres  : 1
     Qual   : None


   Similarly, the codes can be used when specifying the events to monitor.

   Information about what each event measures can be found in the relevant CPU model specific
   documentation.

   The architecture imposes that only two events be defined by all PMUs:

   	- CPU_CYCLES        : the number of elapsed CPU cycles.
	- IA64_INST_RETIRED : the number of instructions retired. 

   Those two events are guaranteed to exist on all PMU but their codes may vary. As alluded to
   earlier, pfmon can support more than one CPU in a single binary. Pfmon also incorporates
   a generic CPU model which provides only the features defined by the architecture, which
   includes the two events. If pfmon does not have specific support for the host CPU it will
   default to the so called 'Generic' CPU support, if compiled in. You can find out what 
   CPU support is compiled into pfmon as follows:

   % pfmon -L
   supported CPU models: [Itanium] [Generic] 
   detected host CPU: Itanium
   kernel perfmon version v1.0 (sampling format v1.0)

   It is possible to force pfmon to operate in generic mode even though it has support for the
   host CPU using the pfmon_gen command:

   % pfmon_gen -L
   forced libpfm to Generic
   supported CPU models: [Itanium] [Generic] 
   detected host CPU: Generic
   kernel perfmon version v1.0 (sampling format v1.0)

   % pfmon_gen -i CPU_CYCLES
   forced libpfm to Generic
   Name   : CPU_CYCLES
   VCode  : 0x12
   Code   : 0x12
   PMD/PMC: [ 4 5 6 7 ]

   The pfmon_gen is not a separate command but just a symlink to pfmon. In fact, pfmon always
   checks the name it was invoked with. If this name is equal to 'pfmon_gen' and the Generic
   support is compiled in, then pfmon will operate in generic mode. Such feature is useful when
   moving pfmon to a CPU for which neither itself nor libpfm have support yet.


3/ Basic counting with pfmon

   In generic mode, pfmon only supports the two architected events listed above but for
   the Itanium CPU up to 150 events are possible.

   No instrumentation of the program are required to monitor using a per-process session. 

   To collect counts on a specific command, you just need to launch it via pfmon, just like
   you would do with the time or strace command:

   % pfmon ls /var/spool
   anacron  at  cron  fax  lpd  mail  mqueue  news  rwho  samba  slrnpull  squid  up2date  uucp  uucppublic  vbox  voice
       2910724 CPU_CYCLES

   When invoked with no particular event, pfmon default to CPU_CYCLES. To monitor specific events,
   you can type:

   % pfmon -e cpu_cycles,IA64_inst_Retired ls /var/spool
   anacron  at  cron  fax  lpd  mail  mqueue  news  rwho  samba  slrnpull  squid  up2date  uucp  uucppublic  vbox  voice
   2984546 CPU_CYCLES
   2666884 IA64_INST_RETIRED

   As you can see, pfmon is not case sensitive with regards to event names. More than one event
   can be measured at a time using a comma separated list of events. You MUST not have space
   after the comma. 

   By default, pfmon will monitor ONLY when the process is executing at the user level, unless
   the -k (or --kernel-level) option is specified. You can monitor at both kernel and user level
   by specifying both -u (--user-level) and -k (--kernel-level):

   % pfmon -k -e ia64_inst_retired -- ls -ial /dev/null
   210135 crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
              1044644 IA64_INST_RETIRED

   % pfmon -u -e ia64_inst_retired -- ls -ial /dev/null
   210135 crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   	      2709733 IA64_INST_RETIRED

   % pfmon -u -k -e ia64_inst_retired -- ls -ial /dev/null
   210135 crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   	      3750206 IA64_INST_RETIRED

   The number of events that can be measured concurrently depends on the underlying CPU model.
   The architecture specifies a minimum of 4 counting monitors. 


   If the command you want to run takes options, you can clearly distinguish the options of 
   pfmon from the options of your command using the '--' symbol:

   % pfmon -e ia64_inst_retired -- ls -ial /dev/null
   210135 crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
              2709704 IA64_INST_RETIRED

   By default, pfmon will start monitoring at the first instruction of the
   program, i.e., the entry point when the privilege level is limited to user
   level. When kernel level is included, monitoring will become active 
   before when the process is context switched in.

   Sometimes, it may be useful to delay the activation of monitoring until
   after a certain point in the execution. This is the case when the
   initialization must not be included in the counts. Pfmon provides a way to
   delay the point at which monitoring is turned on using the
   --start-address option.  This option only apply to per-process sessions
   and is ignored for system-wide.

   Once execution reaches the bundle address specified with the option, the
   monitoring will be turned on and will remain on util the program terminates.
   The address must be specified in hexadecimal. It is not possible to specify
   a kernel address, pfmon will reject any such address. Pfmon will not try to
   validate any user level address. This delayed start mechanism will be used only 
   the first time the address is reached.

   For instance, if we suppose that our test, foo, program main() routine is at
   address 0x40000000000004a0, then we can delay monitoring until main() is
   reached using:
   % pfmon --start-address=0x40000000000004a0 -e loads_retired foo
      74 LOADS_RETIRED

   Whereas the same program executed without the start address, will get:
   % pfmon -e loads_retired foo
      1598 LOADS_RETIRED

   This example proves that the libc initialization used 1598-74=1524 loads all by itself.

4/ System wide sessions

   When the --system-wide flag is used, pfmon operates in system wide mode. This means that
   it does not monitor a specific program anymore but instead all the processes that execute
   on a specific set of CPUs. In this mode, you do no need to specify a command. You do not 
   need to be root to create a system wide session.

   A system wide session cannot co-exist with any per-process sessions. But a system wide session
   can run concurrently with other system wide sessions as long as they do not monitor the same
   set of CPUs. Of course multiple per-process sessions are possible.

   The --cpu-mask option can be used to restrict monitoring to a specific set of CPU. When this
   option is not present, pfmon will automatically launch a system wide session on all available
   CPUs as reported by /proc/cpuinfo.

   A system wide session terminates when the user hit the <Enter> key at which point results
   are printed. Alternatively, the --session-timeout option can be used to limit the
   duration of the session based on time expressed in seconds.


   So if the system has 2 available CPUS:

   % pfmon --system-wide -u -e cpu_cycles,ia64_inst_retired
   <Press ENTER to stop session>
   CPU0                248793 CPU_CYCLES
   CPU0                 60710 IA64_INST_RETIRED
   CPU1                 26690 CPU_CYCLES
   CPU1                  7706 IA64_INST_RETIRED

   A system wide session can monitor at any privilege level (kernel, user, or both).

   If you want to restrict to a specific CPU, you can use the --cpu-mask command:

   % pfmon --system-wide --cpu-mask=0x2 -u -e cpu_cycles,ia64_inst_retired
   <Press ENTER to stop session>
   CPU1                 17841 CPU_CYCLES
   CPU1                  7577 IA64_INST_RETIRED

   The CPU mask is a bitmask where each bit represents a CPU. CPU are numbered starting at 0.
   So bit 1 represents CPU1, bit 2, CPU2 and so on. Therefore the above command will only
   monitor events happening on CPU1. More than one bit can be set in the mask. For instance,
   with --cpu-mask=0x3, pfmon will monitor on CPU0 and CPU1 at the same time.


   It is possible to aggregate counts when monitoring more than one CPU:

   % pfmon --aggregate-results --system-wide -k -e cpu_cycles,ia64_inst_retired
   <Press ENTER to stop session>
            852331455 CPU_CYCLES
           1387206797 IA64_INST_RETIRED

  In which case, the per CPU results are added. Pfmon does not allow  different event to be
  monitored on different CPU. For this you can run separate instances of pfmon with a different
  CPU mask, using a command line similar to:

  % pfmon --session-timeout=10 --cpu-mask=0x1 --system-wide -k -e cpu_cycles &
  % pfmon --session-timeout=10 --cpu-mask=0x2 --system-wide -k -e ia64_inst_retired &


5/ Basic sampling with pfmon

   Pfmon has support for sampling on any events or combination of events. Samples are collected
   into a buffer which can then be written to a file or simply on the screen. 
   
   Each sample is composed of two parts, a fixed size header which contains information about 
   the sample and a variable body which consists of a set of 64-bit values each one representing
   a PMD register. All samples record the same set of PMDs, this set is determine by pfmon based
   on what is being measured.
   
   The sampling buffer is controlled by the kernel but its size is configurable. By default
   pfmon uses a buffer with 2048 entries. This can be changed using the --smpl-entries option.

   The sampling works as follows:
   	1- the user specifies what needs to be recorded.
	2- the user specifies the sampling period.
	3- at the end of a period, a sample is recorded into the buffer by the kernel.
	4- the sampling period is reloaded and execution/monitoring resumes. we go back to step 3.
	5- if the sampling buffer becomes full, pfmon is notified.
	6- pfmon processes the buffer, i.e., print and/or save the buffer.
	7- pfmon then notifies the kernel that it is done.
	8- the kernel reload the sampling period and execution/monitoring resumes. we go back to 3.


   Pfmon (and the kernel) uses two sampling periods instead of just one. The first one is called
   short-smpl-period and the second is called long-smpl-period. The short-smpl-period is used 
   in step 4, this is when the sampling buffer is not full after writing the sample. The 
   long-smpl-period is used in step 8 when the reload occurs after the buffer became full. 

   But why do we need 2 periods?

   As you might imagine there is some overhead is recording a sample. This overhead is
   increased even more when pfmon needs to get involved to drain the buffer. This operation
   can take some time and will inevitably introduce some noise in the measurements in the form
   of TLB and/or cache pollution. To try and hide this noise, it is sometimes beneficial to
   adjust the sampling period, i.e., make it larger to ensure that the next sample will not
   record an event that is the consequence of the overhead generated by the monitoring but rather
   a normal event occuring in the program/system being monitored. So it is expect that the 
   long-smpl-period >= short-smpl-period. Of course if the two are equal, this is equivalent to 
   having only one sampling period. Note that the long-smpl-period is only used to set the 
   distance to the first sample recorded after the buffer is marked as empty again (step 7).



   Pfmon can process the sampling buffer in three different ways depending on the level of 
   readability required by the user. There are three output formats for the sampling buffer: 
   detailed, compact, and raw. The 'detailed' format provides decoded (fully readable) information
   about each sample. The compact format puts each sample in a readable form but on a single line
   and table format. Finally, the raw format saves the data in binary format as it is in the 
   sampling buffer.

   Let us give some examples:

   	Suppose you want to record how many instructions are retired every 50000 cycles, i.e.,
	you want to sample based on CPU_CYCLES and record the value of IA64_INST_RETIRED in 
	each sample. This can be done as follows:

	% pfmon --short-smpl-period=50000 --long-smpl-period=50000 -e cpu_cycles,ia64_inst_retired -- ls /dev/null

	The two periods are identical in this example because the number of instruction executed
	by the ls command is not influenced by the fact that we monitor. The syntax is such that
	the 50000 value of short-period applies to the first event specified in the event list.
	The same rule applies for long-period. 

	With pfmon it is possible to use more than one event as the 'sampling event'. You
	can also specify a sampling period for IA64_INST_RETIRED, in which case we take a sample
	whenever the first OR second period expires:


	% pfmon --short-smpl-period=50000,10000 --long-smpl-period=50000,10000 -e cpu_cycles,ia64_inst_retired ls

	Here a sample will be recorded every 50000 cpu cycles OR each time 10000 instructions have
	been retired.

   You do not necessarily need to specify both periods. If you specify one, then pfmon will use the values to
   initialize the other one. In other words, as soon as you specify only one period, the unspecified one will
   get the same value.

   Now let us look at the information in the sampling buffer. By default, pfmon uses the 'detailed' format.
   For the first example above, we get something like this printed on the screen:

   
   		/dev/null
		Entry 0 PID:1490 CPU:3 STAMP:0x39e28c5cf782 IIP:0x2000000000004c70
	        	PMD OVFL: CPU_CYCLES(4) 
			PMD5  : 0x0000000000004708
		Entry 1 PID:1490 CPU:3 STAMP:0x39e28c5f8e0a IIP:0x2000000000026ee0
        		PMD OVFL: CPU_CYCLES(4) 
        		PMD5  : 0x0000000000007310
		Entry 2 PID:1490 CPU:3 STAMP:0x39e28c6273d2 IIP:0x2000000000025e40
        		PMD OVFL: CPU_CYCLES(4) 
        		PMD5  : 0x000000000000b5e6
		Entry 3 PID:1490 CPU:3 STAMP:0x39e28c63ef1b IIP:0x2000000000018490
        		PMD OVFL: CPU_CYCLES(4) 
        		PMD5  : 0x000000000001137f
		Entry 4 PID:1490 CPU:3 STAMP:0x39e28c64c6f5 IIP:0x2000000000024f60
        		PMD OVFL: CPU_CYCLES(4) 
        		PMD5  : 0x0000000000018a73
		Entry 5 PID:1490 CPU:3 STAMP:0x39e28c6596cb IIP:0x2000000000018490
        		PMD OVFL: CPU_CYCLES(4) 
        		PMD5  : 0x00000000000222df
		.....
   The first line is the output from the ls command. Next you see the entries extracted from the sampling buffer.
   Entry 0 is the first entry recorded in this monitoring session. The first line of each sample (entry) shows
   the fixed header. The fields are as follows:

   	- PID: the identity of the process that generated the event
	- CPU: the CPU number on which the event occurred
	- STAMP: a time stamp guaranteed to be unique in time.
	- IIP  : the value of the IP when the event occurred (DANGER, see note below)
	- PMD_OVFL: the counter that triggered the recording of the sample (more than one possible). 

   VERY IMPORTANT NOTE:
   Users are advised NOT TO TRUST the value reported in IIP.  Samples get recorded by forcing a counter overflow 
   and which then triggers an interrupt which will cause the kernel to record the information. Because of the
   parallel nature of the architecture and its implementations, it is very likely that by the time the PMU realizes
   that there was a counter overflow and generates the interrupt, the program execution has progressed way beyond
   the instruction that caused the event leading the a skewed IIP. At best IIP points to the next bundle given 
   that interrupts can only be delivered at bundle boundaries.

   After the header, you get the value of PMD5. This register contains the number of instructions retired for our
   example. The second event specified by the user DOES NOT necessarily end up in PMD5. To figure out how the
   events were dispatched among the various counter, you can use the --with-header option. It will generate a
   detailed machine and session description before the first sample. In our case it would like as follows:

	#
	#
	# page size: 16384 bytes
	# CLK_TCK: 1024 ticks/second
	# CPU configured: 4
	# CPU online: 4
	# physical memory: 4231446528
	# physical memory available: 3386540032
	#
	# CPU0 Itanium C0  800 Mhz
	#       PAL_A: 6.6.23
	#       PAL_B: 7.7.27
	#       Cache levels: 3 Unique caches: 4
	#       L1D:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L1I:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L2 :    98304 bytes, line 64 bytes, load_lat 6, store_lat 6
	#       L3 :  4194304 bytes, line 64 bytes, load_lat 21, store_lat 21
	# CPU1 Itanium C0  800 Mhz
	#       PAL_A: 6.6.23
	#       PAL_B: 7.7.27
	#       Cache levels: 3 Unique caches: 4
	#       L1D:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L1I:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L2 :    98304 bytes, line 64 bytes, load_lat 6, store_lat 6
	#       L3 :  4194304 bytes, line 64 bytes, load_lat 21, store_lat 21
	# CPU2 Itanium C0  800 Mhz
	#       PAL_A: 6.6.23
	#       PAL_B: 7.7.27
	#       Cache levels: 3 Unique caches: 4
	#       L1D:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L1I:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L2 :    98304 bytes, line 64 bytes, load_lat 6, store_lat 6
	#       L3 :  4194304 bytes, line 64 bytes, load_lat 21, store_lat 21
	# CPU3 Itanium C0  800 Mhz
	#       PAL_A: 6.6.23
	#       PAL_B: 7.7.27
	#       Cache levels: 3 Unique caches: 4
	#       L1D:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L1I:    16384 bytes, line 32 bytes, load_lat 2, store_lat 0
	#       L2 :    98304 bytes, line 64 bytes, load_lat 6, store_lat 6
	#       L3 :  4194304 bytes, line 64 bytes, load_lat 21, store_lat 21
	#
	# monitoring at user level: Y
	# monitoring at kernel level: N
	# mode: per-process
	#
	# command: pfmon --with-header --short-smpl-periods=50000 --long-smpl-periods=50000 -e cpu_cycles,ia64_inst_r etired ls /dev/null 
	#
	#
	# sampling format: 1.0
	# entry size: 48
	# captured events: CPU_CYCLES(PMD4) IA64_INST_RETIRED(PMD5) 
	# recorded PMDs: PMD5 
	# sampling entries: 2048
	#
	# sampling rates (short/long): CPU_CYCLES(50000/50000), IA64_INST_RETIRED(none)
	#
	#
	
    Near the end, you see the assignments: 	IA64_INST_RETIRED(PMD5).

    Pfmon will record the value of the PMD for which the event has no sampling period defined. For our
    first example, it means that it will record the value of the PMD counting the number of instructions 
    retired. Let us look at a more complicated example using some of the Itanium specific events:

    % pfmon --with-header --short-smpl-periods=50000 --long-smpl-periods=50000 \
      -e cpu_cycles,ia64_inst_retired,l2_misses,cpu_cpl_changes -- ls /dev/null

    Here cpu_cycles is controlling the sampling period and each sample will include value of the PMDs counting
    the number of L2 misses (L2_MISSES) and the number of CPU privilege level changes (CPU_CPL_CHANGES):


    Entry 0 PID:1513 CPU:3 STAMP:0x3aa05174be80 IIP:0x200000000000e5e0
        PMD OVFL: CPU_CYCLES(4) 
        PMD5  : 0x0000000000006fce
        PMD6  : 0x00000000000006e7
        PMD7  : 0x0000000000000055

    Where the assignments were: CPU_CYCLES(PMD4) IA64_INST_RETIRED(PMD5) L2_MISSES(PMD6) CPU_CPL_CHANGES(PMD7) 

    Using the compact format, you get results that are formatted such that they can be easily parsed by other
    tools:

    #
    #
    0        1519     0  0x00003ad187edd7fe 0x0010 0x000000000000553b 0x0000000000000408 0x000000000000003e 
    1        1519     0  0x00003ad187f1b350 0x0010 0x000000000000a06c 0x0000000000000dbc 0x000000000000006a 
    2        1519     0  0x00003ad187f3357b 0x0010 0x000000000001054e 0x00000000000011d3 0x0000000000000074 
    3        1519     0  0x00003ad187f41002 0x0010 0x0000000000016ba0 0x0000000000001337 0x0000000000000077 
    4        1519     0  0x00003ad187f4e0be 0x0010 0x0000000000021a68 0x000000000000141f 0x0000000000000079 

    Here again the explanation on the counter assignment is visible using the --with-header option:

    # captured events: CPU_CYCLES(PMD4) IA64_INST_RETIRED(PMD5) L2_MISSES(PMD6) CPU_CPL_CHANGES(PMD7) 

   This option also give the description of every column:

    # column 1: entry number
    # column 2: process id
    # column 3: CPU number
    # column 4: unique timestamp
    # column 5: bitmask of PMDs which overflowed
    # column 6: PMD5
    # column 7: PMD6
    # column 8: PMD7

    
   It is possible to strip the entry (sample) header in compact mode using the --smpl-no-entry-header option:

   #
   #
   0x0000000000006b79 0x0000000000000775 0x0000000000000053 
   0x000000000000ef16 0x000000000000111b 0x0000000000000072 
   0x00000000000182ed 0x00000000000012c9 0x0000000000000076 
   0x0000000000025951 0x00000000000013fd 0x0000000000000078 
   0x0000000000037ea5 0x000000000000148d 0x0000000000000079 
   0x000000000004b44f 0x00000000000014fc 0x000000000000007a 
   0x0000000000060c51 0x0000000000001543 0x000000000000007b 

   And here again the description of the columns is available using the --with-header option:

   # column 1: PMD5
   # column 2: PMD6
   # column 3: PMD7

   The sampling buffer can be written to a file using the --smpl-outfile option.

   When sampling, the counts printed at the end of the session are not very useful, especially for
   the counters used as sampling periods. Those should be discarded and they are NOT saved in the 
   sampling result file.


   Sampling is possible in the same manner for system wide sessions. By default, the buffer is printed on the
   controlling tty. When sampling on more than one CPU at a time, samples for each CPU will be printed. When
   sampling results are redirected into a file, then you get one file per CPU. If the file is called
   'myresults', then 'myresults.cpu0' contains the samples captured on CPU0, 'myresults.cpu1' the ones from CPU1,
   and so on.

   The --aggregate-results options also influences the way samples are saved to files. When this option is used,
   then samples are merged into a single file. In our example, they would go into 'myresults'. If you don't use
   the --smpl-no-entry-header every sample will have the CPU information. 
   

5/ Itanium features supported by pfmon

   Pfmon provides access to ALL the Itanium PMU specific features. This includes:

   	- Event Address Registers (Data & Code)
	- Opcode matching (PMC8, PMC9)
	- Address range restrictions (Data & Code)
	- Branch Trace Buffer (BTB)
	- Event thresholds
	- IA-32 execution monitoring

   The Itanium specific options of pfmon are as follows:
   --event-thresholds=thr1,thr2,...	set event thresholds (no space)
   --opc-match8=val			set opcode match for PMC8
   --opc-match9=val			set opcode match for PMC9
   --btb-no-tar				don't capture TAR predictions
   --btb-no-bac				don't capture BAC predictions
   --btb-no-tac				don't capture TAC predictions
   --btb-tm-tk				capture taken IA-64 branches only
   --btb-tm-ntk				capture not taken IA-64 branches only
   --btb-ptm-correct			capture branch if target predicted correctly
   --btb-ptm-incorrect			capture branch if target is mispredicted
   --btb-ppm-correct			capture branch if path is predicted correctly
   --btb-ppm-incorrect			capture branch if path is mispredicted
   --btb-all-mispredicted		capture all mispredicted branches
   --irange=start-end			specify an instruction address range constraint
   --drange=start-end			specify a data address range constraint
   --checkpoint-func=addr		a bundle address to use as checkpoint
   --ia32				monitor IA-32 execution only
   --ia64				monitor IA-64 execution only

   In this section, we review how each feature and related options are used.

   a/ Event thresholds

      Pfmon has support for event thresholds. It is possible to further refine certain events
      using a threshold. If an event as a threshold set to n, it means that the PMU will not
      count the occurrences of that event unless it happens more  than n times per cycles. So, if
      the threshold is zero, which is the default, then ALL occurrences will be recorded. But
      if it is set to 3, then the counter will be increased by one only when more the event
      happens more than 3 times per cycle. Not all events have the same threshold value. 
      You can determine the maximum increment per cycle for each event using 
      the event info (-i) option of pfmon:

      % pfmon -i NOPS_RETIRED
      Name   : NOPS_RETIRED
      VCode  : 0x30
      Code   : 0x30
      PMD/PMC: [ 4 5 ]
      EAR    : No (N/A)
      Umask  : None
      BTB    : No
      MaxIncr: 6  (Threshold [0-5])
      Qual   : [Instruction Address Range] [OpCode Match] 

      The information includes the maximum increment for the event. Here 6 means that the CPU can execute up to 6 nop per cycles
      which correspond to the two bundles maximum window of Itanium. This combination is possible when using the right template
      to fill all the execution units. Next to it you see the allowed values for the threshold which not surprisingly go from
      0 to max increment - 1.

      Now if you want to count the number of times 6 nops are executed in a single cycle, you can do:

      % pfmon --event-threshold=5 -e nops_retired ls /dev/null
           0 NOPS_RETIRED

      Luckily enough, there is no such bundled executed with the invocation of ls!

      You can specify the thresholds for every event you use. They MUST be specified in the same order as the event.


   b/ Opcode matchers (PMC8, PMC9)

      pfmon has two options to support this features:
      	--opc-match8: set the value for PMC8 (first opcode matcher)
	--opc-match9: set the valuer for PMC9 (second opcode matcher)

      Pfmon does not do any modifications on the values provided by the user. The value of the register must be
      provide in hexadecimal format. These options constraint what is included in the measurement but does not
      set what is to be measured, i.e. which event. Many times, the user just wants to count the number of 
      occurrences of a certain instruction or instruction pattern. For this, you need to combine PMC8/PMC9 with
      an event. To count the number of machine instruction constrained by:

      	- PMC8 you need to use the IA64_TAGGED_INST_RETIRED_PMC8 event
	- PMC9 	you need to use the IA64_TAGGED_INST_RETIRED_PMC9 event

      For instance, if you want to count the number of br.cloop in a program using PMC8, you can do:

      	% pfmon --opc-match8=0x1400028003fff1f8 -e ia64_inst_retired,IA64_TAGGED_INST_RETIRED_PMC8 ls /dev/null
	/dev/null
		 2462367 IA64_INST_RETIRED
		    3658 IA64_TAGGED_INST_RETIRED_PMC8

      The IA64_INST_RETIRED event captured the total number of instructions executed whereas the other event
      counted only the one matched by PMC8.

      To understand the value (0x1400028003fff1f8) please refer to the Itanium Performance Monitoring documentation.
      
      The two opcode matcher are not symmetrical in what the can measure, please refer to documentation for further
      information.

      Not all events can be constrained with the opcode matcher. Pfmon will reject any invalid combination.
      You can figure out if an event support the opcode matcher feature using the event info option of pfmon:

      % pfmon -i cpu_cycles
	Name   : CPU_CYCLES
	VCode  : 0x12
	Code   : 0x12
	PMD/PMC: [ 4 5 6 7 ]
	EAR    : No (N/A)
	Umask  : None
	BTB    : No
	MaxIncr: 1  (Threshold 0)
	Qual   : None

     Here you see on the Qual line that CPU_CYCLES does not support any constraint at all. But if we look at
     NOPS_RETIRED: 
     % pfmon -i nops_retired
       Name   : NOPS_RETIRED
       VCode  : 0x30
       Code   : 0x30
       PMD/PMC: [ 4 5 ]
       EAR    : No (N/A)
       Umask  : None
       BTB    : No
       MaxIncr: 6 (Threshold [0-5])
       Qual   : [Instruction Address Range] [OpCode Match] 

   You see that this event support opcode matching: 'OpCode Match'

   c/ Address Range Restrictions

      Pfmon allows the monitoring to be constrained to a certain range of data or code addresses and provides
      the following set of options:

   	--irange=start-end 	: specify a code address range
   	--drange=start-end 	: specify a data address range
	--checkpoint-func=addr	: specify a checkpoint address

      The third option is a refinement of the first option as we will shortly.

      The range must be specified in hexadecimal: 0x1000-0x2000. Pfmon currently supports only one range per type at a 
      time, e.g., you cannot specify two instruction ranges. Pfmon does not try to see if the range represents
      a valid part of the address space of the process. It will simply do sanity check on the bounds.

      The Itanium PMU imposes some restrictions on alignment of the ranges due to the way they are implemented, i.e.,
      using the debug registers. It is possible that the programmed range will be slightly larger than what was asked
      for. Pfmon takes care of programming the debug registers given the bounds of the range. In some cases, more 
      than one debug register is needed to cover a range of addresses. You can determine by how much the
      debug registers will 'bleed' from the specified range by using the --verbose option of pfmon:

      %  pfmon --verbose --irange=0x1000-0x1895 -e ia64_inst_retired /bin/ls
      ...
      range_restriction: 3 register pairs used
      db0: 0x0000000000001000 db1: plm=0x8 mask=0x00fffffffffff800 end=0x0000000000001800
      db2: 0x0000000000001800 db3: plm=0x8 mask=0x00ffffffffffff80 end=0x0000000000001880
      db4: 0x0000000000001880 db5: plm=0x8 mask=0x00ffffffffffffe0 end=0x00000000000018a0
      range end offset: +0xb
      ...

      As you can see here, the programmed range ends 11 bytes after the specified range for size
      and alignment reasons.  Most of the time, this is harmless except in situations where the excess range
      is heavily used as this would cause noise to be included in the final counts.
   
      Just like for the opcode matcher, not all events support address range restrictions, you can use the
      event info option (-i) to verify.

      The --drange options works just like the --irange options. In fact, both can be combined as they rely
      on distinct sets of debug registers.

      IMPORTANT:
   	   The program being monitored by pfmon MUST NOT be using the debug registers for itself.


      The --checkpoint-func option is a variation of the --irange option. It allows a user to specify  a bundle
      address and can be used to verify that execution crossed a certain point (bundle). So when the bundle
      is the first of a function, you can check how many times the function was called. You need to combine
      the constraint with the IA64_INST_RETIRED event. The result then needs to be divided by three to get
      the number of calls. Note that pfmon does not impose that the bundle be the first of a function, in fact,
      it can be anything. There is no equivalent of this option for data.

      You can easily count the number of times a system called, let us say getpid(2), is called. You need
      to find the address of the function. For sys_getpid(), you can look at the kernel symbol table which
      is typically available in the System.map file. Once you have this address you can simply do:

      % pfmon -k --checkpoint-func=0xe0000000045036e0 -e ia64_inst_retired ls /dev/null
	   27 IA64_INST_RETIRED

      For kernel level function, you obviously need to specify that monitoring should happen at the kernel
      level using the -k option. The results is ALWAYS a multiple of 3 as you have 3 instructions per
      bundle (predicated off instruction are counted here). So if you divide by 3, you have the number
      of time getpid() was call by the ls command: 27/3=9 times.

      The use of any other event is possible here if that event supports the instruction address range
      restriction. But to count the number of time the function is invoked you MUST use IA64_INST_RETIRED.

      At this point only one checkpoint per session is supported.

   
   d/ Event Address Registers (EARS)

   The Event Address Registers provide a way to capture where cache and TLB
   misses occur. For each captured miss, you get the instruction address, the
   data address (when relevant), the latency of the miss (when relevant), the
   TLB level at which the miss was resolved (if relevant).

   Let us first look at cache misses. You can filter out which misses you are
   interested in based on the miss latency. EARS DO NOTY CAPTURE NON MISSING
   cache accesses. For instance you can say that you want misses that take
   more than 16 cycles to resolve. The Itanium PMU supports a fixed set of 
   latencies going from 4 to 4096. Of course not all latencies are possible,
   they are usually powers of two. The Itanium PMU uses two event to indicate
   the type of cache misses: code or data. The INSTRUCTION_EAR_CACHE is used
   for instruction and DATA_EAR_CACHE is used for data cache misses.
   Theoretically, the latency is programmed in one the field on the PMC
   controlling the monitor. However to make it easier to use, the library
   on which pfmon is built with encapsulates the latency with the event by
   creating 'virtual events'. If you list the events using pfmon -l and look
   for the ones with EAR in their names:

   % pfmon/pfmon -l | fgrep EAR
	INSTRUCTION_EAR_EVENTS
	DATA_EAR_EVENTS
	DATA_EAR_CACHE_LAT4
	DATA_EAR_CACHE_LAT8
	DATA_EAR_CACHE_LAT16
	DATA_EAR_CACHE_LAT32
	DATA_EAR_CACHE_LAT64
	DATA_EAR_CACHE_LAT128
	DATA_EAR_CACHE_LAT256
	DATA_EAR_CACHE_LAT512
	DATA_EAR_CACHE_LAT1024
	DATA_EAR_CACHE_LAT2048
	DATA_EAR_CACHE_LAT_NONE
	DATA_EAR_TLB_L2
	DATA_EAR_TLB_VHPT
	DATA_EAR_TLB_SW
	INSTRUCTION_EAR_CACHE_LAT4
	INSTRUCTION_EAR_CACHE_LAT8
	INSTRUCTION_EAR_CACHE_LAT16
	INSTRUCTION_EAR_CACHE_LAT32
	INSTRUCTION_EAR_CACHE_LAT64
	INSTRUCTION_EAR_CACHE_LAT128
	INSTRUCTION_EAR_CACHE_LAT256
	INSTRUCTION_EAR_CACHE_LAT512
	INSTRUCTION_EAR_CACHE_LAT1024
	INSTRUCTION_EAR_CACHE_LAT2048
	INSTRUCTION_EAR_CACHE_LAT4096
	INSTRUCTION_EAR_CACHE_LAT_NONE
	INSTRUCTION_EAR_TLB_VHPT
	INSTRUCTION_EAR_TLB_SW

   You see the virtual events for both TLB and caches. For instance, DATA_EAR_CACHE_LAT64
   is the event used to capture data cache misses with a latency of 64 cycles
   OR more. Similarly, the DATA_EAR_TLB_VHPT is used to capture TLB misses
   that were resolved by the hardware walker (VHPT).

   You can get detailed information about EAR events using the event info (-i) option
   of pfmon:

   % pfmon -i DATA_EAR_CACHE_LAT_NONE
   Name   : DATA_EAR_CACHE_LAT_NONE
   VCode  : 0xf0367
   Code   : 0x67
   EAR    : Data (Cache Mode) Umask: 1111
   Umask  : None
   PMD/PMC: [4 5 6 7]
   MaxIncr: 1  (Threshold 0)
   Qual   : [Instruction Address Range] [OpCode match] 

   The EARs are mostly used for sampling, therefore you typically associate a
   sampling period to them. You configure a sampling period with EAR just like
   you would do with regular counters.

   But let us take a simple example to help visualize the difference. Let us
   suppose you want to capture the data cache misses that take more than 8
   cycles. The sampling period is set to 2000 which is quite small but is just
   used to show the sampling output:

   % pfmon/pfmon --long-smpl-periods=2000 -e DATA_EAR_CACHE_LAT8 -- ls -l /dev/null
   crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   Entry 0 PID:810 CPU:1 STAMP:0x8395a8f188 IIP:0x2000000000029860
        PMD OVFL: DATA_EAR_CACHE_LAT8(4) 
        PMD2  : 0x200000000003fb00
        PMD3  : 0x0000000000000018 , (Latency 24)
        PMD17 : 0x2000000000014185 valid=Y instruction address 0x2000000000014181
   Entry 1 PID:810 CPU:1 STAMP:0x8395b86696 IIP:0x20000000000a6280
        PMD OVFL: DATA_EAR_CACHE_LAT8(4) 
        PMD2  : 0x200000000027efe0
        PMD3  : 0x0000000000000021 , (Latency 33)
        PMD17 : 0x200000000016a1f5 valid=Y instruction address 0x200000000016a1f1
   Entry 2 PID:810 CPU:1 STAMP:0x8395ccbb32 IIP:0x2000000000024f80
        PMD OVFL: DATA_EAR_CACHE_LAT8(4) 
        PMD2  : 0x2000000000034900
        PMD3  : 0x0000000000000014 , (Latency 20)
        PMD17 : 0x2000000000024fa1 valid=Y instruction address 0x2000000000024fa0
 18446744073709550313 DATA_EAR_CACHE_LAT8

   Here again, we get sampling entries which the usual header. However the
   information in the body of each sample is quite different from what we saw 
   earlier. In detailed mode, pfmon will decode the meaning of each PMD. For
   instance, which EAR and data cache misses, PMD3 contains the latency of the
   miss. In Entry 0, the miss took 24 cycles to resolve. The data that was
   being access what at address 0x200000000003fb00 (PMD2) and the instruction
   which generated the access what at 0x2000000000014181, WHICH YOU NEED TO
   INTERPRET as  0x2000000000014180 Slot 1. In compact mode, no interpretation
   is done by pfmon.

   If we look at the TLB instead, we get samples that we look as follows:

   % pfmon --long-smpl-periods=50 -e DATA_EAR_TLB_VHPT -- ls -l /dev/null
   crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   Entry 0 PID:851 CPU:0 STAMP:0x1be3b8277a8 IIP:0x2000000000018540
        PMD OVFL: DATA_EAR_TLB_VHPT(4) 
        PMD2  : 0x200000000007ebb4
        PMD3  : 0x8000000000000001 , TLB VHPT
        PMD17 : 0x2000000000018535 valid=Y instruction address 0x2000000000018531
   Entry 1 PID:851 CPU:0 STAMP:0x1be3baab8b9 IIP:0xe0000000044012a0
        PMD OVFL: DATA_EAR_TLB_VHPT(4) 
        PMD2  : 0x20000000002cc000
        PMD3  : 0x8000000000000001 , TLB VHPT
        PMD17 : 0x20000000000bed81 valid=Y instruction address 0x20000000000bed80
    18446744073709551607 DATA_EAR_TLB_VHPT

   Note that this time the interpretation of PMD3 has changed. In TLB mode, you 
   specify the level at which you want to capture the misses. Here we wanted
   TLB request that missed in L1 but hit in VHPT and that is what is reflected
   by PMD3. There is no latency information on TLB misses. PMD17 contains the 
   address of the instruction that caused the TLB miss. And PMD2 is the address
   of the data that was being accessed.

   Cache and TLB misses can also be captured for instructions. Pfmon operates
   in the same manner for instruction. The difference is in the information
   that is captured. 

   For instance, if we want to capture the instruction TLB misses that hit in the VHPT
   we get something similar to:

   % pfmon --long-smpl-periods=50 -e INSTRUCTION_EAR_TLB_VHPT -- ls -l /dev/null
   crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   Entry 0 PID:863 CPU:0 STAMP:0x216d944c332 IIP:0xe0000000044012a0
        PMD OVFL: INSTRUCTION_EAR_TLB_VHPT(4) 
        PMD0  : 0x20000000002130c1, valid=Y cache line 0x20000000002130c0 (TLB VHPT)
   Entry 1 PID:863 CPU:0 STAMP:0x216d9475fd0 IIP:0x2000000000013e00
        PMD OVFL: INSTRUCTION_EAR_TLB_VHPT(4) 
        PMD0  : 0x2000000000013e01, valid=Y cache line 0x2000000000013e00 (TLB VHPT)
   Entry 2 PID:863 CPU:0 STAMP:0x216d955c9fa IIP:0x2000000000118320
        PMD OVFL: INSTRUCTION_EAR_TLB_VHPT(4) 
        PMD0  : 0x2000000000118321, valid=Y cache line 0x2000000000118320 (TLB VHPT)
   Entry 3 PID:863 CPU:0 STAMP:0x216d95e19ba IIP:0x2000000000151530
        PMD OVFL: INSTRUCTION_EAR_TLB_VHPT(4) 
        PMD0  : 0x2000000000151521, valid=Y cache line 0x2000000000151520 (TLB VHPT)
   Entry 4 PID:863 CPU:0 STAMP:0x216d9634f95 IIP:0x400000000000a6e0
        PMD OVFL: INSTRUCTION_EAR_TLB_VHPT(4) 
        PMD0  : 0x400000000000a6e1, valid=Y cache line 0x400000000000a6e0 (TLB VHPT)

   This time, the set of PMD used to capture the information is different, allowing
   both data and instruction EAR to operate in parallel. In our example, PMD0 contains
   the address of the cache line that caused the TLB miss (which was resolved by the VHPT).

   For instruction cache misses, we get:

   % pfmon --long-smpl-periods=5000 -e INSTRUCTION_EAR_CACHE_LAT8 -- ls -l /dev/null
   crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   Entry 0 PID:872 CPU:0 STAMP:0x253839a1599 IIP:0x20000000000c7920
        PMD OVFL: INSTRUCTION_EAR_CACHE_LAT8(4) 
        PMD0  : 0x20000000000bd4e1, valid=Y cache line 0x20000000000bd4e0
        PMD1  : 0x0000000000000016, (Latency 22)
   Entry 1 PID:872 CPU:0 STAMP:0x25383a7be92 IIP:0x200000000026e460
        PMD OVFL: INSTRUCTION_EAR_CACHE_LAT8(4) 
        PMD0  : 0x20000000000a59e1, valid=Y cache line 0x20000000000a59e0
        PMD1  : 0x0000000000000034, (Latency 52)
    18446744073709550323 INSTRUCTION_EAR_CACHE_LAT8

   This time both PMD0 and PMD1 contains relevant information. PMD0 contains the address
   of the cache line that caused the miss and PMD1 the latency to resolve it.

   e/ Branch Trace Buffer (BTB)

   The BTB is used to capture branch events. Depending on the configuration of the BTB,
   it is possible to record the source and target of each branch instruction. It is possible
   to filter out branches based on how they were predicted by the hardware, whether they
   were taken or not taken, and so on. Each qualified branch is recorded into the branch
   buffer, and usually takes two entries (a pair) one for the source 
   (the branch instruction itself) and one for the target of the branch.  The hardware buffer
   has a size of 8 meaning that it can hold up to 4 branch events.  The buffer is managed like
   a ring buffer, once it is full the oldest entries get overwritten. The PMD16 register
   is used to maintain the index, i.e., were to write next. It also contains a flag indicating
   whether or not the buffer wrapped around. 

   You can count how many branch are captured using the BRANCH_EVENT event. You MUST 
   use this event if you want to sample with the BTB. Because the BTB can hold 4 branches,
   sampling with the BTB means that at the end of each sampling period, up to the last
   4 branches are recorded.

   By default, pfmon will capture ALL branches (taken, not taken, predicted correctly or mispredicted).
   Let us take a look at a simple example:

   % pfmon --long-smpl-periods=50000 -e branch_event -- ls -l /dev/null
   crw-rw-rw-    1 root     root       1,   3 Mar 24  2001 /dev/null
   Entry 0 PID:927 CPU:0 STAMP:0x471b41a1eb3 IIP:0x2000000000024f80
        PMD OVFL: BRANCH_EVENT(4) 
        PMD8 : 0x2000000000024f9d b=1 mp=0 valid=Y
                Source Address: 0x2000000000024f90 (slot 3)
                Prediction: Success

        PMD9 : 0x2000000000024fa2 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024fa0

        PMD10: 0x2000000000024fb9 b=1 mp=0 valid=Y
                Source Address: 0x2000000000024fb0 (slot 2)
                Prediction: Success

        PMD11: 0x2000000000024f62 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024f60

        PMD12: 0x2000000000024f7d b=1 mp=0 valid=Y
                Source Address: 0x2000000000024f70 (slot 3)
                Prediction: Success

        PMD13: 0x2000000000024f82 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024f80

        PMD14: 0x2000000000024f9d b=1 mp=0 valid=Y
                Source Address: 0x2000000000024f90 (slot 3)
                Prediction: Success

        PMD15: 0x2000000000024fa2 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024fa0

   Entry 1 PID:927 CPU:0 STAMP:0x471b41e0ab1 IIP:0x2000000000024f60
        PMD OVFL: BRANCH_EVENT(4) 
        PMD11: 0x2000000000024f7d b=1 mp=0 valid=Y
                Source Address: 0x2000000000024f70 (slot 3)
                Prediction: Success

        PMD12: 0x2000000000024f82 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024f80

        PMD13: 0x2000000000024f9d b=1 mp=0 valid=Y
                Source Address: 0x2000000000024f90 (slot 3)
                Prediction: Success

        PMD14: 0x2000000000024fa2 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024fa0

        PMD15: 0x2000000000024fb9 b=1 mp=0 valid=Y
                Source Address: 0x2000000000024fb0 (slot 2)
                Prediction: Success

        PMD8 : 0x2000000000024f62 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024f60

        PMD9 : 0x2000000000024f7d b=1 mp=0 valid=Y
                Source Address: 0x2000000000024f70 (slot 3)
                Prediction: Success

        PMD10: 0x2000000000024f82 b=0 mp=1 valid=Y
                Target Address: 0x2000000000024f80


   This time, each entry contains as many as 8 PMDs. Because of wrap around conditions, there
   is not guarantee that the buffer will be full. It depends of the sampling period and
   how it compares to the size of the BTB. The BRANCH_EVENT counter is incremented by 1 
   FOR EACH PAIR OF ENTRIES (each branch event). So if BRANCH_EVENT is equal to 4, then 8
   4 branches (or 8 entries) are in the BTB.

   The branch are recorded one after the other. But because of wrap around conditions, you
   can have situations where PMD8 is not necessarily the first, i.e., the oldest branch
   event in the buffer. This can easily be seen in the example above. Pfmon prints
   the BTB in sequential order, i.e., in the order in which the branches occurred. This is
   true in detailed sampling mode, but NOT for the compact or raw sampling output modes. For those,
   the user must rely on PMD16 which included in the compact and raw modes.

   So if we look at Entry 0, PMD8 is the oldest branch in the buffer. IT contains a branch
   source that was located at address 0x2000000000024f90 in slot 3 of the bundle. It was
   predicted correctly by the hardware and it branched to address 0x2000000000024fa0.


   It is possible to vary the kind of branches that are recorded using the following options:
   --btb-no-tar				don't capture TAR predictions
   --btb-no-bac				don't capture BAC predictions
   --btb-no-tac				don't capture TAC predictions

   These three options relate to the Itanium branch architecture. Please refer to proper 
   documentation for further information on the TAR, BAC, and TAC.


   --btb-tm-tk				capture taken IA-64 branches only
   --btb-tm-ntk				capture not taken IA-64 branches only

   These are easy to understand!

   --btb-ptm-correct			capture branch if target predicted correctly
   --btb-ptm-incorrect			capture branch if target is mispredicted
   --btb-ppm-correct			capture branch if path is predicted correctly
   --btb-ppm-incorrect			capture branch if path is mispredicted

   Same here.

   --btb-all-mispredicted		capture all mispredicted branches
 
   This one is a freebie, it combines the other to capture only the mispredicted branches.


   It possible to combine BTB and EAR sampling. One interesting case is when you combine
   the BTB (taken branches) with the instruction cache misses. For each cache miss captured,
   you will get the last 4 branches that led to the misses. So you'll have the last few
   steps in the path that led to the fault. With this information, one can imagine possible
   optimizations such as prefetching.

   f/ IA-32 execution

   By default, pfmon captures events for both IA-32 and IA-64 programs. Not all events
   are functional in IA-32 mode. The following features are not available when monitoring
   in IA-32 mode ONLY:
   	- The Branch Trace Buffer  (BRANCH_EVENT)
	- Code range restriction (--irange, --checkpoint-func)
	- Data range restriction (--drange)
	- Opcode matchers (--opc-match8, --opc-match9)

   However those features are accepted when monitoring for both IA-64 and
   IA-32 (default). The results will ONLY represent what was generated by the
   IA-64 execution.

   Using the --ia32 option, the user restricts monitoring to execution occuring while
   psr.is = 1, i.e., for IA-32 code. Using the --ia64 restricts monitoring to IA-64
   code only, i.e., psr.is = 0.

   Linux/ia64 does not currently support processes where both instructions set are
   mixed. However the dual mode (IA-32, IA-64) is interesting when running system
   wide monitoring where all execution is captured. The Linux/ia64 kernel execution
   ALWAYS happens in IA-64 mode, therefore using --ia32 to monitor kernel level execution
   has no effect.

   Similarly, some events are only relevant in one mode. For instance, IA32_INST_RETIRED
   only counts IA-32 instructions. Conversly, IA64_INST_RETIRED will return 0 on an IA-32 program.
   The following examples use the date program imported from a Linux/ia32 system:

   % file date.x86
   date.x86: ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked (uses shared libs), stripped

   % pfmon  -e cpu_cycles,ia64_inst_retired,ia32_inst_retired date.x86
   Mon Feb 11 00:50:58 PST 2002
              3182458 CPU_CYCLES
                    0 IA64_INST_RETIRED
               497506 IA32_INST_RETIRED

   % pfmon  --ia64 -e cpu_cycles,ia64_inst_retired,ia32_inst_retired date.x86
   Mon Feb 11 00:51:52 PST 2002
                    0 CPU_CYCLES
                    0 IA64_INST_RETIRED
                    0 IA32_INST_RETIRED

   % pfmon  --ia32 -e cpu_cycles,ia64_inst_retired,ia32_inst_retired date.x86
   Mon Feb 11 00:46:36 PST 2002
              2919710 CPU_CYCLES
                    0 IA64_INST_RETIRED
               497532 IA32_INST_RETIRED

6/ Further documentation

   You can find a lot of information about the Linux/ia64 kernel in the book:

   	'ia-64 linux kernel design and implementation' 
   	David Mosberger and Stephane Eranian
	Prentice Hall
	ISBN: 0130610143
	Available Feb'02

   This book contains a chapter about the IA-64 PMU, the design of the kernel perfmon subsystem
   and also a small description of pfmon.


   More detailed information about the IA-64 architecture, including the PMU can be found
   on the Intel developers' web site at:

   		http://developer.intel.com/design/itanium

   For the Itanium Processor specific information (including PMU description), 
   please refer to the documents:
	- Intel Itanium Processor Reference Manual for Software Development
	- Intel Itanium Processor Reference Manual for Software Optimization

   which are available at the above web site.

7/ Support

   You can subscribe to the official Linux/ia64 mailing list at www.linuxia64.org.

   Alternatively, you send send me an E-mail at eranian@hpl.hp.com 

8/ Bug reports

   You can send a bug report to myself at eranian@hpl.hp.com.
   Patches are also welcome.

   	
01/25/2002
S.Eranian <eranian@hpl.hp.com>


API:
- 2.5.23 dropped smp_num_cpus and cpu_logical_map(). The API to
  global-mode counters uses logical cpu numbers [0..smp_num_cpus[
  which won't work in 2.5/2.6.

Driver:
- When an overflown perfctr is reset, we should take into account
  how many events past 0 or 1 it is at.
- Add check for MP P4s with HT enabled and refuse to run on them
  or ensure clients have a CPU affinity mask retricting them to
  logical CPU #0 in each HT P4 package.
- Remote control for ptrace ATTACHed and stopped processes.

Library:
- Add vperfctr_mmap() to libperfctr.c: the goal is to perform all
  accesses via the library, even for examples/perfex/.
- Implement gethrvtime(). Don't ever STOP the counters. To stop PMC
  updates, call CONTROL with tsc_on == 1 and nractrs == nrictrs == 0.
  The driver will continue sampling the TSC. Then gethrvtime() reduces
  to scaling the virtualised TSC with cpu_khz.
- Split libperfctr.c's core/virtual/global/misc stuff into separate files.
- Describe P4 events in event_set.c.
- Describe both primitive and derived events in event_set.c.

Documentation:
- Write it :-(

Possible Changes:
- The P6 and P4 sub-models don't matter for the driver. Should the driver
  just export the major model and the cpuid, and let user-space figure
  out sub-model details?
- Access control mechanism for global-mode perfctrs?
- Interrupt support for global-mode perfctrs?
- Multiplexing support? PAPI seems to do fine w/o it.
- A "kernel profiling" mode which uses global-mode perfctrs in
  interrupt mode to profile the kernel?
- Buffer interrupts and signal user-space when buffer is nearly full?

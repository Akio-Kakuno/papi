.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Erik Hendriks
.\" <hendriks@cesdis.gsfc.nasa.gov>
.\"
.TH PERF 2  "16 February 1999" "Linux" "Linux Programmer's Manual"
.SH NAME
perf_reset, perf_set_config, perf_get_config, perf_start, perf_stop,
perf_read, perf_write, perf_wait \- hardware performance counter manipulation functions
.SH SYNOPSIS
.B #include <perf.h>
.sp
.BI "int perf_reset(void);"
.br
.BI "int perf_reset_counters(void);"
.br
.BI "int perf_set_config(int " counter ", int " config ");"
.br
.BI "int perf_get_config(int " counter ", int *" config ");"
.br
.BI "int perf_set_opt(int " option ", int " value ");"
.br
.BI "int perf_get_opt(int " option ", int *" value ");"
.br
.BI "int perf_start(void);"
.br
.BI "int perf_stop(void);"
.br
.BI "int perf_read(int " counter ", unsigned long long *" dest ");"
.br
.BI "int perf_fastread(unsigned long long *" dest ");"
.br
.BI "int perf_write(int " counter ", unsigned long long *" src ");"
.br
.BI "int perf_wait(pid_t " pid ", int *" status ", int " options ","
.br
.BI "              struct rusage *" ru ","
.br
.BI "              unsigned long long *" counts ");"

.BI "int perf_sys_reset(void);"
.br
.BI "int perf_sys_set_config(int " cpu ", int " counter ","
.br
.BI "                        int " event ", int " flags ");"
.br
.BI "int perf_sys_get_config(int " cpu ", int " counter ","
.br
.BI "                        int *" event ", int *" flags ");"
.br
.BI "int perf_sys_start(void);"
.br
.BI "int perf_sys_stop(void);"
.br
.BI "int perf_sys_read(int " cpu ", int " counter ","
.br
.BI "                  unsigned long long *" dest ");"
.br
.BI "int perf_sys_write(int " cpu ", int " counter ","
.br
.BI "                   unsigned long long *" src ");"

.SH DESCRIPTION

The
.B perf_reset
function clears the configuration and counter registers.  If counting
was started, it will be stopped.

The
.B perf_set_config
function is used to select what will be counted in each counter.  (The
Pentium Pro has two counters.)  The
.B config
argument is one of the countable events (see below) and may be OR'ed
with zero or more flags.  Note that some values can only be counted in
certain counters.  This function has the side effect of stopping the
counters and resetting them back to zero.

As the name suggests, the
.B perf_get_config
function can be used to read back the configuration.  This value may
not be exactly the same as what was written because of defaults that
may be assigned.  (See
.B PERF_OS
and
.B PERF_USR
below.)

The
.B perf_start
and
.B perf_stop
functions start and stop the counters.  These should be used after
configuring the counters.

The
.B perf_read
and
.B perf_write
functions are used to read and write the values of the counters.

By default counting occurs only in user mode and for the process that
configures the counters.  Multiple processes can count at once.
(Counter states and values are saved and restored at context
switches.)

The
.B perf_wait
function is an extension of the
.BR wait "(4)"
function.  Its operation is identical except that it can also return
the values of the performance counters at the time that the process
exited.  The counts argument should be an array of length
.B PERF_COUNTERS

The
.B sys
versions of these calls perform analogous functions except that
counting is system-wide instead of being restricted to the calling
process.  While system wide counting is in progress, per-processing
counting is unavailable.  Using any of the per-process functions will
yield
.B EBUSY.

Using any of the perf_sys_* functions (except for
.B perf_sys_reset
) will enable system wide counting and will interrupt any per-process
counting that might be in progress.  Calling
.B perf_sys_reset
frees the performance counters for per-process use.  Note that the
system-wide counting does NOT stop if the process manipulating the
counters exits.

On SMP machines, every CPU has its own configuration and set of
counters.  These are configured and read separately but started and
stopped together using the
.B perf_sys_start
and
.B perf_sys_stop
functions.

Only the super-user may use the system wide counter functions.

.SH SYSTEM CALLS
.TP
.B fork()
Counting configuration is not inherited by the child process.
.TP
.B exec()
After an
.B exec()
the counter configuration is unchanged and counting will continue if
started.
.PP
.SH COUNTABLE EVENTS \- Data Cache Unit (DCU)
.TP
.B PERF_DATA_MEM_REFS
All memory references, both cacheable and non\-cacheable.
.TP
.B PERF_DCU_LINES_IN
Total lines allocated in the DCU.
.TP
.B PERF_DCU_M_LINES_IN
Number of M state lines allocated in the DCU.
.TP
.B PERF_DCU_M_LINES_OUT
Number of M state lines evicted from the DCU.  This includes
evictions via snoop HITM, intervention or replacement.
.TP
.B PERF_DCU_MISS_STANDING
Weighted number of cycles while a DCU miss is outstanding.

.SH COUNTABLE EVENTS \- Instruction Fetch Unit (IFU)
.TP
.B PERF_IFU_IFETCH
Number of instruction fetches, both cacheable and non-cacheable.
.TP
.B PERF_IFU_IFETCH_MISS
Number of instruction fetch misses.
.TP
.B PERF_ITLB_MISS
Number of ITLB misses.
.TP
.B PERF_IFU_MEM_STALL
Number of cycles that the instruction fetch pipe stage is stalled
including cache misses, ITLB misses, ITLB faults, and victim cache
evictions.
.TP
.B PERF_ILD_STALL
Number of cycles that the instruction length decoder is stalled.

.SH COUNTABLE EVENTS \- L2 Cache

.TP
.B PERF_L2_IFETCH
Number of L2 instruction fetches.  Requires MESI flags.
.TP
.B PERF_L2_LD
Number of L2 data loads.  Requires MESI flags.
.TP
.B PERF_L2_ST
Number of L2 data stores.  Requires MESI flags.
.TP
.B PERF_L2_LINES_IN
Number of lines allocated in the L2.
.TP
.B PERF_L2_LINES_OUT
Number of lines removed from the L2 for any reason.
.TP
.B PERF_L2_LINES_INM
Number of modified lines allocated in the L2.
.TP
.B PERF_L2_LINES_OUTM
Number of modified lines removed from the L2 for any reason.
.TP
.B PERF_L2_RQSTS
Number of L2 requests.  Requires MESI flags.
.TP
.B PERF_L2_ADS
Number of L2 address strobes.
.TP
.B PERF_L2_DBUS_BUSY
Number of cycles during which the data bus was busy.
.TP
.B PERF_L2_DBUS_BUSY_RD
Number of cycles during which the data bus was busy transferring
data from the L2 to the processor.


.SH COUNTABLE EVENTS \- External Bus Logic
.TP
.B PERF_BUS_DRDY_CLOCKS
Number of clocks during which DRDY is asserted.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_LOCK_CLOCKS
Number of clocks during which LOCK is asserted.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_REQ_OUTSTANDING
Number of bus requests outstanding.
.TP
.B PERF_BUS_TRAN_BRD
Number of burst read transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_RFO
Number of read for ownership transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRANS_WB
Number of write back transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_IFETCH
Number of instruction fetch transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_INVAL
Number of invalidate transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_PWR
Number of partial write transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_P
Number of partial transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRANS_IO
Number of IO transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_DEF
Number of deferred transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_BURST
Number of burst transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_ANY
Number of all transactions.  Requires SELF/ANY flags.
.TP
.B PERF_BUS_TRAN_MEM
Number of memory transactions.   Requires SELF/ANY flags.
.TP
.B PERF_BUS_DATA_RCV
Number of bus clock cycles during which this processor is receiving data.
.TP
.B PERF_BUS_BNR_DRV
Number of bus clock cycles during which this processor is driving the
BNR pin.
.TP
.B PERF_BUS_HIT_DRV
Number of bus clock cycles during which this processor is driving the
HIT pin.
.TP
.B PERF_BUS_HITM_DRV
Number of bus clock cycles during which this processor is driving the
HITM pin.
.TP
.B PERF_BUS_SNOOP_STALL
Number of clock cycles during which the bus is snoop stalled.

.SH COUNTABLE EVENTS \- Floating point unit
.TP
.B PERF_FLOPS
Number of computational floating\-point operations retired.  Counter 0 only.
.TP
.B PERF_FP_COMP_OPS_EXE
Number of computational floating\-point operations executed.  Counter 0 only.
.TP
.B PERF_FP_ASSIST
Number of floating\-point exception cases handled by microcode.  Counter 1 only.
.TP
.B PERF_MUL
Number of multiplies.  Counter 1 only.
.TP
.B PERF_DIV
Number of divides.  Counter 1 only.
.TP
.B PERF_CYCLES_DIV_BUSY
Number of cycles during which the divider is busy.  Counter 0 only.

.SH COUNTABLE EVENTS \-  Memory Ordering 
.TP
.B PERF_LD_BLOCK
Number of store buffer blocks.
.TP
.B PERF_SB_DRAINS
Number of store buffer drain cycles.
.TP
.B PERF_MISALIGN_MEM_REF
Number of misaligned data memory references.

.SH COUNTABLE EVENTS \-  Instruction Decoding and Retirement
.TP
.B PERF_INST_RETIRED
Number of instructions retired.
.TP
.B PERF_UOPS_RETIRED
Number of UOPS retired.
.TP
.B PERF_INST_DECODER
Number of instructions decoded.

.SH COUNTABLE EVENTS \-  Interrupts
.TP
.B PERF_HW_INT_RX
Number of hardware interrupts received.
.TP
.B PERF_CYCLES_INST_MASKED
Number of processor cycles for which interrupts are disabled.
.TP
.B PERF_CYCLES_INT_PENDING_AND_MASKED
Number of processor cycles for which interrupts are disabled and
interrupts are pending.

.SH COUNTABLE EVENTS \- Branches
.TP
.B PERF_BR_INST_RETIRED
Number of branch instructions retired.
.TP
.B PERF_BR_MISS_PRED_RETIRED
Number of mispredicted branches retired.
.TP
.B PERF_BR_TAKEN_RETIRED
Number of taken branches retired.
.TP
.B PERF_BR_MISS_PRED_TAKEN_RET
Number of taken mispredicted branched retired.
.TP
.B PERF_BR_INST_DECODED
Number of branch instructions decoded.
.TP
.B PERF_BR_BTB_MISSES
Number of branches that miss the BTB.
.TP
.B PERF_BR_BOGUS
Number of bogus branches.
.TP
.B PERF_BACLEARS
Number of times BACLEAR is asserted.

.SH COUNTABLE EVENTS \- Stalls
.TP
.B PERF_RESOURCE_STALLS
Number of cycles during which there are resource related stalls.
.TP
.B PERF_PARTIAL_RAT_STALLS
Number of cycles or event for partial stalls.

.SH COUNTABLE EVENTS \- Segment Register Loads
.TP
.B PERF_SEGMENT_REG_LOADS
Number of segment register loads.

.SH COUNTABLE EVENTS \- Clocks
.TP
.B PERF_CPU_CLK_UNHALTED
Number of cycles during which the processor is not halted.
.PP

.SH COUNTER FLAGS
Many of the external bus logic events can be further qualified with
either the
.B PERF_SELF
or
.B PERF_ANY
flags.
.TP
.B PERF_SELF
Count events for this processor only.
.TP
.B  PERF_ANY
Count events for any processor.
.PP

Many of the L2 cache events to be counted can be further qualified
with the following flags.  These flags can be OR'ed together to count
more than one cache state.
.TP
.B PERF_CACHE_M
Count events for modified cache lines.
.TP
.B PERF_CACHE_E
Count events for exclusive cache lines.
.TP
.B PERF_CACHE_S
Count events for shared cache lines.
.TP
.B PERF_CACHE_I
Count events for invalid cache lines.
.TP
.B PERF_CACHE_ALL
Count events for all cache states.

.PP

The flags
.B PERF_OS
and
.B PERF_USR
flags allow you to control when counting should occur.  These two
flags can be combined.  The default (when no flag is specified) for
per-process counting is
.B PERF_USR
only and the default for system-wide counting is
.B PERF_OS
only.

.TP
.B PERF_OS
Count events only when the processor is operating in
system mode.  (privilege level 0)
.TP
.B PERF_USR
Count events only when the processor is operating in user
mode. (privilege levels 1, 2 or 3)
.PP

.SH RETURN VALUE
All the functions return 0 on success and \-1 on error.

.SH ERRORS
.TP
.B EBUSY
The counters are being used for system-wide counters are not available
for per-process counting.
.TP
.B EPERM
A non-root user attempted to use the system-wide profiling functions.	
.PP

.SH BUGS
When system-wide monitoring is used, the other processes get no
indication that their monitoring has been corrupted.

.SH SEE ALSO
The
.I Pentium Pro Family Developer's Manual
volume 3.  This is available from http://developer.intel.com

.BR wait4 "(2)" 


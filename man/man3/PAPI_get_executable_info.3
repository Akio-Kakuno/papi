.\" $Id$
.TH PAPI_get_executable_info 3 "November, 2003" "PAPI Programmer's Reference" PAPI

.SH NAME
PAPI_get_executable_info \- get the executable's address space info

.SH SYNOPSIS
.B C Interface
.nf
.B #include <papi.h>
.BI "const PAPI_exe_info_t *PAPI_get_executable_info(void);"
.fi
.B Fortran Interface
.nf
.B #include "fpapi.h"
.BI PAPIF_get_exe_info(C_STRING\  fullname,\  C_STRING\  name,\ \
           C_LONG_LONG\  text_start,\  
.BI \tC_LONG_LONG\  text_end,\  C_LONG_LONG\  data_start,\ \
           C_LONG_LONG\  data_end,\ 
.BI \tC_LONG_LONG\  bss_start,\  C_LONG_LONG\  bss_end,\ 
.BI \tC_STRING\  lib_preload_env,\ C_INT\  check)
.fi

.SH DESCRIPTION
In C, this function returns a pointer to a structure containing information about
the current program. In Fortran, some fields of the structure are returned explicitly.

.SH ARGUMENTS
The following arguments are implicit in the structure returned by the C function,
or explicitly returned by Fortran.
.LP
.I fullname
--  fully qualified path + filename of the executable
.LP
.I name
--  filename of the executable with no path information
.LP
.I text_start, text_end
--  Start and End addresses of program text segment
.LP
.I data_start, data_end
--  Start and End addresses of program data segment
.LP
.I bss_start, bss_end
--  Start and End addresses of program bss segment
.LP
.I lib_preload_env
--  environment variable for preloading libraries

.SH RETURN VALUES
On success, the C function returns a non-NULL pointer, 
and the Fortran function returns 
.B PAPI_OK.
 On error, NULL is returned by the C function, 
and a non-zero error code is returned by the Fortran function.

.SH ERRORS
.TP
.B "PAPI_EINVAL"
One or more of the arguments is invalid.

.SH EXAMPLE
.LP
.nf
.if t .ft CW
const PAPI_exe_info_t *prginfo = NULL;
	
if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT)
  exit(1);

if ((prginfo = PAPI_get_executable_info()) == NULL)
  exit(1);

printf("Start of user program is at %p\en",prginfo->text_start);
printf("End of user program is at %p\en",prginfo->text_end);
.if t .ft P
.fi

.SH DATA STRUCTURES
.LP
.nf
.if t .ft CW
   typedef struct _papi_preload_option {
      char lib_preload_env[PAPI_MAX_STR_LEN];   /* Model string of CPU */
      char lib_preload_sep;
      char lib_dir_env[PAPI_MAX_STR_LEN];
      char lib_dir_sep;
   } PAPI_preload_option_t;

   typedef int (*PAPI_debug_handler_t) (int code);

   typedef struct _papi_address_map {
      char mapname[PAPI_MAX_STR_LEN];
      caddr_t text_start;       /* Start address of program text segment */
      caddr_t text_end;         /* End address of program text segment */
      caddr_t data_start;       /* Start address of program data segment */
      caddr_t data_end;         /* End address of program data segment */
      caddr_t bss_start;        /* Start address of program bss segment */
      caddr_t bss_end;          /* End address of program bss segment */
   } PAPI_address_map_t;

   typedef struct _papi_program_info {
      char fullname[PAPI_MAX_STR_LEN];  /* path+name */
      char name[PAPI_MAX_STR_LEN];      /* name */
      PAPI_address_map_t address_info;
      PAPI_preload_option_t preload_info;
   } PAPI_exe_info_t;
.if t .ft P
.fi

.SH AUTHORS
The PAPI Team. See them at the PAPI Web Site: 
http://icl.cs.utk.edu/projects/papi

.SH BUGS
Only the
.I text_start
and
.I text_end
fields are filled on every architecture.

.SH SEE ALSO
.BR PAPI_library_init "(3), "
.BR PAPI_get_hardware_info "(3), "
.BR PAPI_get_opt "(3)" 

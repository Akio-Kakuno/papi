.\" $Id$
.TH PAPI_get_overflow_event_index 3 "November, 2003" "PAPI Programmer's Reference" "PAPI"

.SH NAME
PAPI_get_overflow_event_index \- decomposes an overflow_vector into an event index array in which the first element corresponds to the least significant set bit in overflow_vector and so on.
.SH SYNOPSIS
.B C Interface
.nf
.B #include <papi.h>
.BI "int PAPI_get_overflow_event_index(int " EventSet ", long long " overflow_vector ", int *" array ", int *" number ");"
.fi
.B Fortran Interface
.nf
.B #include "fpapi.h"
.BI PAPIF_get_overflow_event_index(C_INT\  EventSet,\  C_LONG_LONG\  Overflow_vector,\  C_INT(*)\  Array,\  C_INT\  number,\  C_INT\  check )
.fi

.SH DESCRIPTION
.LP
.B PAPI_get_overflow_event_index(\|)
decomposes an overflow_vector into an event index array in which the first element corresponds to the least significant set bit in overflow_vector and so on. Based on overflow_vector, the user can only tell which physical counters overflowed. The user can get the information about which events overflowed through this function. 


.SH ARGUMENTS
.I EventSet 
--  an integer handle for a PAPI event set as created by
.BR "PAPI_create_eventset" (3)
.LP
.I overflow_vector 
--  a vector containing the set bits about which counters overflowed 
.LP
.I *Array 
-- an array of indexes for events No more than 
.I *number
indexes will be stored into the array.
.LP
.I *number 
-- On input the variable determines the size of the 
.I Array 
array. On output the variable contains the number of indexes in the
Array.
.LP
Note that if the given array
.I *Array
is too short to hold all the indexes correspond to the set bits in the overflow_vector the
.I *number
variable will be set to the size of Array.

.SH RETURN VALUES
On success, this function returns
.B "PAPI_OK."
 On error, a non-zero error code is returned.

.SH ERRORS
.TP
.B "PAPI_EINVAL"
One or more of the arguments is invalid.
.TP
.B "PAPI_ENOEVST"
The EventSet specified does not exist.
.TP

.SH EXAMPLES
.nf
.if t .ft CW

long long vector;
void handler(int EventSet, void *address, long_long overflow_vector, void *context)
{
   if (!TESTS_QUIET) {
      fprintf(stderr, OVER_FMT, EventSet, address, overflow_vector);
   }
   total++;
   vector = overflow_vector;
}

int main(int argc, char **argv)
{

  int EventCode, EventSet = PAPI_NULL;
  int Events[4], number = 4;
  int retval;
	
  if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_OK);
    handle_error(1);

  /* Create an EventSet */
  if (PAPI_create_eventset(&EventSet) != PAPI_OK)
    handle_error(1);

  /* Add Total Instructions Executed to our EventSet */

  if (PAPI_add_event(EventSet, EventCode) != PAPI_OK)
    handle_error(1);

  if (PAPI_overflow(EventSet, PAPI_event, 100000, 0, handler)!= PAPI_OK;
    handle_error(1);
 retval = PAPI_start(EventSet);
   if (retval != PAPI_OK)
      test_fail(__FILE__, __LINE__, "PAPI_start", retval);

   do_flops(NUM_FLOPS);

   retval = PAPI_stop(EventSet, values[1]);
   if (retval != PAPI_OK)
      test_fail(__FILE__, __LINE__, "PAPI_stop", retval);

   retval = PAPI_overflow(EventSet, PAPI_event, 0, 0, handler);
   if (retval != PAPI_OK)
      test_fail(__FILE__, __LINE__, "PAPI_overflow", retval);

   number = 4;
   retval = PAPI_get_overflow_event_index(EventSet,
                 vector, eventindex, &number);
   if (retval != PAPI_OK)
      test_fail(__FILE__, __LINE__, "PAPI_get_overflow_event_index", retval);

}
.if t .ft P
.fi

.SH AUTHORS
The PAPI Team. See them at the PAPI Web Site: 
http://icl.cs.utk.edu/projects/papi

.SH BUGS
This function has no known bugs.

.SH SEE ALSO
.BR PAPI_overflow "(3)" 

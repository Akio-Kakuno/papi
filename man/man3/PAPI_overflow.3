.\" $Id$
.TH PAPI_overflow 3 "December, 2001" "PAPI Function Reference" "PAPI"

.SH NAME
PAPI_overflow, PAPI_get_overflow_address \- set up an event set 
to begin registering overflows; return the address at which an overflow occured

.SH SYNOPSIS
.B C Interface
.nf
.B #include <papi.h>
.BI "int\ PAPI_overflow (int " EventSet ", int " EventCode ", int " threshold ", int " flags ", PAPI_overflow_handler_t " handler ");"
.BI "void\ *PAPI_get_overflow_address (void *" context );
.fi
.B Fortran Interface
.nf
.I Not implemented
.fi

.SH DESCRIPTION
.B PAPI_overflow()
marks a specific 
.I EventCode 
in an 
.I EventSet 
to generate an overflow signal after every 
.I threshold
events are counted. Only one event in an event set can be used as 
an overflow trigger.  Subsequent calls to
.B PAPI_overflow() 
replace earlier calls. To turn off overflow, set the handler to NULL.

.B PAPI_get_overflow_address()
returns the instruction pointer where overflow occured. This routine is often used
as part of the overflow handler routine.

.SH ARGUMENTS
.I EventSet 
-- a reference to the event set to use
.LP
.I EventCode 
-- the counter to be used for overflow detection
.LP
.I threshold 
-- the overflow threshold value to use
.LP
.I flags 
-- bit map that controls the overflow mode of operation. This is
currently not used and should be set to 0.
.LP
.I handler 
-- the handler function to call upon overflow
.LP
.I context 
-- a platform dependent structure containing information about the overflow event.
This structure is typically returned automatically by the signal handler.

.SH RETURN VALUES
On success, PAPI_overflow returns
.B "PAPI_OK."
 On error, a non-zero error code is returned.
 PAPI_get_overflow_address returns the instruction pointer where the 
overflow occured. PAPI_get_overflow_address always returns the value 
at the offset in the 
.I context
structure where the instruction pointer should be. No validity testing of 
this structure is done. If an invalid context pointer is passed to this function,
the results will be undefined.

.SH ERRORS
.TP
.B "PAPI_EINVAL"
One or more of the arguments is invalid.
.TP
.B "PAPI_ENOMEM"
Insufficient memory to complete the operation.
.TP
.B "PAPI_ENOEVST"
The EventSet specified does not exist.
.TP
.B "PAPI_EISRUN"
The EventSet is currently counting events.
.TP
.B "PAPI_ECNFLCT"
The underlying counter hardware can not count this event and other events
in the EventSet simultaneously.
.TP
.B "PAPI_NOEVNT"
The PAPI preset is not available on the underlying hardware. 

.SH EXAMPLES
.nf
.if t .ft CW
void handler(int EventSet, int EventCode, int EventIndex, long_long *values, int *threshold, void *context)
{
  fprintf(stderr,"Value %lld at %p\en",
	  values[EventIndex],PAPI_get_overflow_address(context));
#endif
  total++;
}

  int EventSet = PAPI_NULL;
	
  if (PAPI_create_eventset(&EventSet) != PAPI_OK)
    handle_error(1);

  /* Add Total Instructions Executed to our EventSet */

  if (PAPI_add_event(&EventSet, PAPI_TOT_INS) != PAPI_OK)
    handle_error(1);

  /* Call handler every 100000 instructions */

  retval = PAPI_overflow(EventSet, PAPI_TOT_INS, THRESHOLD, 0, handler);
  if (retval != PAPI_OK)
    exit(1);

  /* Start counting */

  if (PAPI_start(EventSet) != PAPI_OK)
    handle_error(1);

.if t .ft P
.fi

.SH AUTHOR
Philip J. Mucci <mucci@cs.utk.edu>

.SH BUGS
These functions have no known bugs.

.SH SEE ALSO
.BR PAPI_preset "(3), "
.BR PAPI_set_opt "(3), " PAPI_start "(3), " PAPI_rem_event "(3), " 
.BR PAPI_rem_events "(3), " PAPI_query "(3), "
.BR PAPI_cleanup_eventset "(3), " PAPI_destroy_eventset "(3), " 
 The PAPI Web Site: 
http://icl.cs.utk.edu/projects/papi
